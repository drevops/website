//
// Spotlight component.
//

@use 'sass:map';

// Container class should wrap every row.
.container {
  @include ct-container();
}

.container-fluid {
  @include ct-container(false);
}

@include ct-cssgrid();

.row {
  $root: &;

  &#{$root}--no-gutters {
    margin-right: 0;
    margin-left: 0;

    > .col,
    > [class*='col-'] {
      padding-right: 0;
      padding-left: 0;
    }
  }

  &#{$root}--no-grow {
    > .col,
    > [class*='col-'] {
      width: auto;
    }
  }

  &#{$root}--fill-width {
    // @todo
  }

  &#{$root}--equal-heights-content {
    > .col,
    > [class*='col-'] {
      > * {
        height: 100%;
      }
    }
  }

  &#{$root}--unequal-heights {
    > .col,
    > [class*='col-'] {
      margin-bottom: auto;
    }
  }

  &#{$root}--vertically-spaced {
    @each $bp, $gutter in $ct-grid-vertical-gutters {
      @if $bp == $ct-grid-lowest-breakpoint {
        row-gap: $gutter;
        margin-bottom: $gutter;
      }
      @else {
        @include ct-breakpoint($bp) {
          row-gap: $gutter;
          margin-bottom: $gutter;
        }
      }
    }
  }
}

ul.row {
  margin-top: 0;
  margin-bottom: 0;
  padding-left: 0;
  list-style: none;
}

.col {
  $root: &;

  // Make columns at the lowest breakpoint to act as a single column per row.
  @include _ct-grid-col($ct-grid-lowest-breakpoint, $ct-grid-columns);

  $next-bp: ct-map-get-next($ct-breakpoints, $ct-grid-lowest-breakpoint, map.get($ct-breakpoints, 'xxs'), key);

  @include ct-breakpoint($next-bp) {
    grid-column: span 1;
  }
}

// Generate column classes for CSS Grid
@each $breakpoint, $value in $ct-breakpoints {
  @if $breakpoint == $ct-grid-lowest-breakpoint {
    @for $i from 1 through $ct-grid-columns {
      .col-#{$breakpoint}-#{$i} {
        grid-column: span $i;
      }
    }
  }
  @else {
    @include ct-breakpoint($breakpoint) {
      @for $i from 1 through $ct-grid-columns {
        .col-#{$breakpoint}-#{$i} {
          grid-column: span $i;
        }
        @include _ct-col-factory($breakpoint);
      }
    }
  }
}

// Utilities for columns
.col,
[class*='col-'] {
  box-sizing: border-box;

  &.col--reverse {
    display: flex;
    flex-direction: column-reverse;
  }

  &.col--no-grow {
    width: auto;
  }

  &.col--no-gap {
    // Isolate this column from grid gaps
    @include ct-breakpoint($ct-grid-responsive-breakpoint) {
      margin: 0 -#{map.get($ct-grid-gutters, $ct-grid-responsive-breakpoint) / 2};
    }
  }
}

// Order utilities
@each $breakpoint, $value in $ct-breakpoints {
  @if $breakpoint == $ct-grid-lowest-breakpoint {
    .first {
      order: -1;
    }

    .last {
      order: 1;
    }
  }
  @else {
    @include ct-breakpoint($breakpoint) {
      .first-#{$breakpoint} {
        order: -1;
      }
      .last-#{$breakpoint} {
        order: 1;
      }
    }
  }
}
